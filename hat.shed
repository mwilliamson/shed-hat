public val hat = object {
    public def TestResult class(errors: List[AssertionError]) => {
        public def isSuccess fun() => errors.isEmpty();
        public def getErrors fun() => errors;
    }
        
    public def AssertionError class(description: String) => {
        public def getDescription fun() => description;
    }
        
    public val results = object {
        public def success fun() : TestResult => TestResult(emptyList);
        
        public def failure fun(description: String) : TestResult => do {
            val error = AssertionError(description);
            return TestResult(listOf[AssertionError](error));
        }
        
        public def all fun(results: List[TestResult]) => do {
            val getErrors = fun(result: TestResult) => result.getErrors();
            val concat = fun[T] => (first: List[T], second: List[T]) => first.concat(second);
            val errors = results
                .map(getErrors)
                .foldLeft(emptyList, concat[AssertionError]);
            return TestResult(errors);
        }
    };
    
    public def TestCase class(description: String, func: () -> TestResult) => {
        public def getDescription fun() : String => description;
        public def run fun() : TestResult => func();
    }
    
    public def assertTrue fun(value: Boolean) =>
        if value then
            results.success()
        else
            results.failure("Expected true, got false");
    
    public def assertFalse fun(value: Boolean) =>
        if not(value) then
            results.success()
        else
            results.failure("Expected false, got true");
    
    public def assertEquals fun[T] => (expected: T, actual: T) =>
        if expected.equals(actual) then do {
            return results.success();
        } else do {
            val message = "Expected "
                .concat(representation(expected))
                .concat(", got ")
                .concat(representation(actual));
            return results.failure(message);
        };
    
    def TestResults class(results: List[TestResult]) => {
        public def add fun(result: TestResult) =>
            TestResults(results.append(result));
        
        public def isSuccess fun() : Boolean =>
            failures().isEmpty();
        
        public def numberOfTests fun() : Double =>
            results.length();
        
        public def failures fun() : List[TestResult] =>
            results.filter(fun (result: TestResult) => not(result.isSuccess()));
    }
    
    public def runTestCases fun(testCases: List[TestCase]) : Unit => do {
        val results = testCases.map(runTestCase);
        return results.foldLeft(TestResults(emptyList), combineResults);
    }
    
    def combineResults fun(results: TestResults, result: TestResult) =>
        results.add(result);

    val greenCode = "\u001B[32m";
    val redCode = "\u001B[31m";
    val blackCode = "\u001B[39m";

    def runTestCase fun(testCase: TestCase) : TestResult => do {
        val description = testCase.getDescription();
        print(description.concat("..."));
        val result = testCase.run();
        print("\r");
        if result.isSuccess() then do {
            print(greenCode);
            print("✔ ");
        } else do {
            print(redCode);
            print("✖ ");
        };
        print(description);
        print(" ");
        print(blackCode);
        print("\n");
        result.getErrors().forEach(fun (error: AssertionError) => do {
            print(error.getDescription());
            print("\n\n");
        });
        return result;
    };
    
    public def run fun(argv: List[String]) => do {
        val testCases = runtimeImport(argv.head());
        val results = runTestCases(testCases);
        if results.isSuccess() then
            printSuccess(results)
        else
            printFailure(results);
    }
    
    def printSuccess fun(results: TestResults) : Unit => do {
        print(greenCode);
        print("✔ ");
        print(results.numberOfTests().toString());
        print(" test(s) passed\n");
        print(blackCode);
    }
    
    def printFailure fun(results: TestResults) : Unit => do {
        val failures = results.failures();
        print(redCode);
        print("✖ ");
        print(failures.length().toString());
        print(" test failures\n");
        print(blackCode);
    }
};
