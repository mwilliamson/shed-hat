public val hat = object {
    public def TestResult class(errors: List[AssertionError]) => {
        public def isSuccess fun() => errors.isEmpty();
        public def getErrors fun() => errors;
    }
        
    public def AssertionError class(description: String) => {
        public def getDescription fun() => description;
    }
        
    public val results = object {
        public def success fun() : TestResult => TestResult(emptyList);
        
        public def failure fun(description: String) : TestResult => {
            val error = AssertionError(description);
            return TestResult(listOf[AssertionError](error));
        }
        
        public def all fun(results: List[TestResult]) => {
            val getErrors = fun(result: TestResult) => result.getErrors();
            val concat = fun[T] => (first: List[T], second: List[T]) => first.concat(second);
            val errors = results
                .map(getErrors)
                .foldLeft(emptyList, concat[AssertionError]);
            return TestResult(errors);
        }
    };
    
    public def TestCase class(description: String, func: () -> TestResult) => {
        public def getDescription fun() : String => description;
        public def run fun() : TestResult => func();
    }
    
    public def assertTrue fun(value: Boolean) => {
        return if value {
            return results.success();
        } else {
            return results.failure("Expected true, got false");
        };
    }
    
    public def assertFalse fun(value: Boolean) => {
        return if not(value) {
            return results.success();
        } else {
            return results.failure("Expected false, got true");
        };
    }
    
    public def assertEquals fun[T] => (expected: T, actual: T) => {
        return if expected.equals(actual) {
            return results.success();
        } else {
            val message = "Expected "
                .concat(representation(expected))
                .concat(", got ")
                .concat(representation(actual));
            return results.failure(message);
        };
    }
    
    def TestResults class(results: List[TestResult]) => {
        public def add fun(result: TestResult) => {
            return TestResults(results.append(result));
        }
        
        public def isSuccess fun() : Boolean => {
            return failures().isEmpty();
        }
        
        public def numberOfTests fun() : Double => {
            return results.length();
        }
        
        public def failures fun() : List[TestResult] => {
            return results
                .filter(fun (result: TestResult) => not(result.isSuccess()));
        }
    }
    
    public def runTestCases fun(testCases: List[TestCase]) : Unit => {
        val results = testCases.map(runTestCase);
        return results.foldLeft(TestResults(emptyList), combineResults);
    }
    
    def combineResults fun(results: TestResults, result: TestResult) => {
        return results.add(result);
    }

    val greenCode = "\u001B[32m";
    val redCode = "\u001B[31m";
    val blackCode = "\u001B[39m";

    def runTestCase fun(testCase: TestCase) : TestResult => {
        val description = testCase.getDescription();
        print(description.concat("..."));
        val result = testCase.run();
        print("\r");
        if result.isSuccess() {
            print(greenCode);
            print("✔ ");
        } else {
            print(redCode);
            print("✖ ");
        };
        print(description);
        print(" ");
        print(blackCode);
        print("\n");
        result.getErrors().forEach(fun (error: AssertionError) => {
            print(error.getDescription());
            print("\n\n");
        });
        return result;
    };
    
    public def run fun(argv: List[String]) => {
        val testCases = runtimeImport(argv.head());
        val results = runTestCases(testCases);
        if (results.isSuccess()) {
            printSuccess(results);
        } else {
            printFailure(results);
        };
    }
    
    def printSuccess fun(results: TestResults) : Unit => {
        print(greenCode);
        print("✔ ");
        print(results.numberOfTests().toString());
        print(" test(s) passed\n");
        print(blackCode);
    }
    
    def printFailure fun(results: TestResults) : Unit => {
        val failures = results.failures();
        print(redCode);
        print("✖ ");
        print(failures.length().toString());
        print(" test failures\n");
        print(blackCode);
    }
};
